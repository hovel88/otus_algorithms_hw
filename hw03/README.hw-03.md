# ДЗ 03: Степень, Числа Фибоначчи, Простые числа

## Цель

Написать и сравнить разные алгоритмы:

* возведения числа в целую степень
* вычисления чисел Фибоначчи
* поиска простых чисел

## Решение

### УРОВЕНЬ JUNIOR

Сборка исходников происходит через `make`, проверялось в Linux.
Выполнено 3 из 3 пунктов без системы тестирования:

#### JUNIOR. Возведение в степень

**1.** Реализован итеративный алгоритм для возведения числа в целую степень (`hw03/issue_power/algo_iterative.cpp`). Сложность алгоритма **O(N)**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_power$ ./hw03_power_iterative 
программа возведения вещественного числа в целую степень (A^N)
обычный итеративный алгоритм. сложность O(N)
число  : 5
степень: 8
результат возведения в степень: 390625
```

#### JUNIOR. Поиска чисел Фибоначчи

**2 а.** Реализован рекурсивный алгоритм для поиска чисел Фибоначчи (`hw03/issue_power/algo_recursive.cpp`). Сложность алгоритма **O(2^N)**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_fibo$ ./hw03_fibo_recursive 
программа поиска чисел Фибоначчи по его номеру
рекурсивный алгоритм. сложность O(2^N)
номер: 40
число Фибоначчи: 102334155
```

**2 б.** Реализован итеративный алгоритм для поиска чисел Фибоначчи (`hw03/issue_power/algo_iterative.cpp`). Сложность алгоритма **O(N)**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_fibo$ ./hw03_fibo_iterative 
программа поиска чисел Фибоначчи по его номеру
итеративный алгоритм. сложность O(N)
номер: 40
число Фибоначчи: 102334155
```

#### JUNIOR. Поиск количества простых чисел

**3.** Реализован алгоритм поиска количества простых чисел через перебор делителей (`hw03/issue_primes/algo_base.cpp`). Сложность алгоритма **O(N^2)**.

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_primes$ ./hw03_primes_base 
программа поиска количества простых чисел до указанного числа N
алгоритм перебора делителей. сложность O(N^2)
число: 100000
количество простых чисел: 9592
```

### УРОВЕНЬ MIDDLE

Сборка исходников происходит через `make`, проверялось в Linux.
Выполнено не менее 4 пунктов без системы тестирования:

#### MIDDLE. Возведение в степень

**11.** Реализован алгоритм через деление степени на четные и нечетные с домножением (`hw03/issue_power/algo_div_power.cpp`). Сложность алгоритма **O(log N)**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_power$ ./hw03_power_div_power 
программа возведения вещественного числа в целую степень (A^N)
алгоритм делением степени на четные и нечетные. сложность O(log N)
число  : 5
степень: 8
результат возведения в степень: 390625
```

**12.** Реализован алгоритм через бинарное возведение в степень через маску (`hw03/issue_power/algo_binary_power.cpp`). Сложность алгоритма **O(log N)**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_power$ ./hw03_power_binary_power 
программа возведения вещественного числа в целую степень (A^N)
алгоритм двоичного разложения показателя степени. сложность O(log N)
число  : 5
степень: 8
результат возведения в степень: 390625
```

#### MIDDLE. Поиска чисел Фибоначчи

**13.** Реализован алгоритм поиска чисел Фибоначчи по формуле золотого сечения (`hw03/issue_fibo/algo_gold.cpp`). Сложность алгоритма **O(1)**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_fibo$ ./hw03_fibo_gold 
программа поиска чисел Фибоначчи по его номеру
алгоритм золотого сечения. сложность O(1)
номер: 40
число Фибоначчи: 102334155
```

**14.** Реализован алгоритм поиска чисел Фибоначчи через умножение матриц (`hw03/issue_fibo/algo_matrix.cpp`). Сложность алгоритма **O(log N)**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_fibo$ ./hw03_fibo_matrix 
программа поиска чисел Фибоначчи по его номеру
алгоритм перемножения матриц. сложность O(log N)
номер: 40
число Фибоначчи: 102334155
```

#### MIDDLE. Поиск количества простых чисел

**15 а.** Реализован алгоритм поиска простых чисел с оптимизацией поиска только до квадратного корня от N (`hw03/issue_primes/algo_sqrt.cpp`). Сложность алгоритма **O(N sqrt(N))**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_primes$ ./hw03_primes_sqrt 
программа поиска количества простых чисел до указанного числа N
алгоритм перебора делителей (с оптимизацией поиска по квадратному корню). сложность O(N sqrt(N))
число: 100000
количество простых чисел: 9592
```

**15 б.** Реализован алгоритм поиска простых чисел с оптимизацией поиска по нечетным числам (`hw03/issue_primes/algo_odd.cpp`). Сложность алгоритма **O(N log N)** (один цикл всё еще полный, второй сокращен вдвое)

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_primes$ ./hw03_primes_odd
программа поиска количества простых чисел до указанного числа N
алгоритм перебора делителей (с оптимизацией поиска по нечетным). сложность O(N log N)
число: 100000
количество простых чисел: 9592
```

**15 в.** Реализован алгоритм поиска простых чисел с оптимизацией поиска только до квадратного корня от N и исключая кратные 2 и 3 (`hw03/issue_primes/algo_sqrt_div_2_3.cpp`). Сложность алгоритма **O(N^(3/2))** (один цикл всё еще полный, второй очень сильно сокращен с отсечением кратных)

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_primes$ ./hw03_primes_sqrt_div_2_3
программа поиска количества простых чисел до указанного числа N
алгоритм перебора делителей (с оптимизацией поиска по нечетным). сложность O(N^(3/2))
число: 100000
количество простых чисел: 9592
```

**15 г.** Реализован алгоритм поиска простых чисел с оптимизацией поиска делением на простые числа (с ограничением по квадратному корню от N и по нечетности) (`hw03/issue_primes/algo_div_primes.cpp`). Сложность алгоритма **O(N sqrt(N) / log(N))**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_primes$ ./hw03_primes_div_primes 
программа поиска количества простых чисел до указанного числа N
алгоритм перебора делителей (с оптимизацией поиска c делением на простые числа). сложность O(N sqrt(N) / log(N))
число: 100000
количество простых чисел: 9592
```

**16.** Реализован алгоритм поиска простых чисел через "решето Эрастофена" (`hw03/issue_primes/algo_eratosthenes.cpp`). Сложность алгоритма **O(N log log N)**

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_primes$ ./hw03_primes_eratosthenes 
программа поиска количества простых чисел до указанного числа N
алгоритм решета Эрастофена. сложность O(N log log N)
число: 100000
количество простых чисел: 9592
```

### УРОВЕНЬ SENIOR

Выполнено 3 из 3 пунктов:

#### SENIOR. Возведение в степень

Реализована система тестирования для алгоритмов:

* итеративный алгоритм для возведения числа в целую степень (сложность **O(N)**)
* алгоритм через деление степени на четные и нечетные с домножением (сложность **O(log N)**)
* алгоритм через бинарное возведение в степень через маску (сложность **O(log N)**)

Исходники системы тестирования находятся в файлах:

* `hw03/issue_power/checker_internals.cpp` - реализация core-функций системы тестирования
* `hw03/issue_power/checker_internals.h` - объявление core-функций
* `hw03/issue_power/checker.cpp` - собственно самая интересная часть

Сборка исходников системы тестирования происходит через `make`:

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_power$ make
g++ -lstdc++fs -std=c++17 -O2 -Wall -I. -o hw03_power_checker checker.cpp checker_internals.cpp algo_iterative.cpp algo_div_power.cpp algo_binary_power.cpp
```

Файлы для системы тестирования через файлы находятся в каталоге `hw03/issue_power/3.Power`

После запуска тестов, система сформирует сводную таблицу со временем исполнения по каждому тесту

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_power$ ./hw03_power_checker

Результаты теста алгоритма через итеративный подход

Test 0 (         870 нс) : успех! ожидалось '1024.0' получено '1024.00000000000'
Test 1 (         249 нс) : успех! ожидалось '1.0' получено '1.00000000000'
Test 2 (        5117 нс) : успех! ожидалось '2.71692393224' получено '2.71692393224'
Test 3 (       50103 нс) : успех! ожидалось '2.71814592682' получено '2.71814592682'
Test 4 (      520733 нс) : успех! ожидалось '2.71826823719' получено '2.71826823719'
Test 5 (     5372493 нс) : успех! ожидалось '2.7182804691' получено '2.71828046910'
Test 6 (    26042010 нс) : успех! ожидалось '2.71828169413' получено '2.71828169413'
Test 7 (   106548998 нс) : успех! ожидалось '2.71828179835' получено '2.71828179835'
Test 8 (  1027851574 нс) : успех! ожидалось '2.71828205201' получено '2.71828205201'
Test 9 ( 10254139351 нс) : успех! ожидалось '2.71828205323' получено '2.71828205323'
------------------
Количество тестов: 10
Успешно          : 10
Провалено        : 0

Результаты теста алгоритма через деление степени на четные и нечетные с домножением

Test 0 (         155 нс) : успех! ожидалось '1024.0' получено '1024.00000000000'
Test 1 (          49 нс) : успех! ожидалось '1.0' получено '1.00000000000'
Test 2 (          91 нс) : успех! ожидалось '2.71692393224' получено '2.71692393224'
Test 3 (         111 нс) : успех! ожидалось '2.71814592682' получено '2.71814592682'
Test 4 (         106 нс) : успех! ожидалось '2.71826823719' получено '2.71826823719'
Test 5 (         151 нс) : неудача! ожидалось '2.7182804691' получено '2.71828046913'
Test 6 (         167 нс) : неудача! ожидалось '2.71828169413' получено '2.71828169406'
Test 7 (         191 нс) : неудача! ожидалось '2.71828179835' получено '2.71828179350'
Test 8 (         212 нс) : неудача! ожидалось '2.71828205201' получено '2.71828203876'
Test 9 (         217 нс) : неудача! ожидалось '2.71828205323' получено '2.71828203321'
------------------
Количество тестов: 10
Успешно          : 5
Провалено        : 5

Результаты теста алгоритма через бинарное возведение в степень через маску

Test 0 (         117 нс) : успех! ожидалось '1024.0' получено '1024.00000000000'
Test 1 (          46 нс) : успех! ожидалось '1.0' получено '1.00000000000'
Test 2 (          93 нс) : успех! ожидалось '2.71692393224' получено '2.71692393224'
Test 3 (         124 нс) : успех! ожидалось '2.71814592682' получено '2.71814592682'
Test 4 (         104 нс) : успех! ожидалось '2.71826823719' получено '2.71826823719'
Test 5 (         104 нс) : неудача! ожидалось '2.7182804691' получено '2.71828046913'
Test 6 (         119 нс) : неудача! ожидалось '2.71828169413' получено '2.71828169406'
Test 7 (         121 нс) : неудача! ожидалось '2.71828179835' получено '2.71828179350'
Test 8 (         140 нс) : неудача! ожидалось '2.71828205201' получено '2.71828203876'
Test 9 (         129 нс) : неудача! ожидалось '2.71828205323' получено '1.15143219085'
------------------
Количество тестов: 10
Успешно          : 5
Провалено        : 5

Сравнение затраченного времени на выполнение (нс)

Group name                   Test 0         Test 1         Test 2         Test 3         Test 4         Test 5         Test 6         Test 7         Test 8         Test 9
binary power                    117             46             93            124            104            104            119            121            140            129
div power                       155             49             91            111            106            151            167            191            212            217
iterative                       870            249           5117          50103         520733        5372493       26042010      106548998     1027851574    10254139351
```

Можно видеть следующее:

* итеративный подход (**iterative**) очень медленный
* подход с разбиением степени на четные и нечетные и домножением (**div power**), а также подход к бинарному разложению степени по маске (**binary power**) работают значительно быстрее
* итеративный подход (**iterative**) дает наиболее точный результат (9 из 9 тестов успешно)!
* подход с разбиением степени на четные и нечетные и домножением (**div power**), а также подход к бинарному разложению степени по маске (**binary power**) дают не такой точный результат (5 из 9 тестов прошли успешно)!

Небольшой выигрыш времени у алгоритма с бинарным разложением степени (**binary power**) связан с тем, что он работает **слева-направо**, т.е. предварительно отсекаем из обработки старшие биты степени (если в старших битах нет 1, то и возведения в степень нет никакого), т.е. заранее сокращается объем работы.

Однако, как видно из результатов тестов, алгоритмы **div power** и **binary power** не дают точного соответствия ожидаемому результату (ошибка начинает накапливаться), а **iterative** дает! Это объясняется тем, что в тестах со 2 до 9 описан особенный случай:

* основание `A` близко к 1
* степень `N` очень большая
* в коде используются представления чисел с плавающей точкой (у них ограниченный диапазон чисел).

Тип **double** из-за ограниченности представления не очень хорошо умеет работать с ошибками близкими к 0. Т.е. он не может точно представить десятичное число с целой частью и одновременно с очень большим числом знаков после запятой (например 1.0000000001). Возникает большая разница порядков и формат **double** не способен вместить в себе такие числа с заданной точностью.

В алгоритме с итеративным подходом (**iterative**), мы планомерно умножали основание `A` (которое вполне хорошо помещалось в **double**), само на себя. Ошибка появлялась, но росла линейно. Получалось так, что 11 значащих цифр после запятой хватило, чтобы ошибка не вылезла.

Но на каждой итерации алгоритмов **div power** и **binary power** происходит возведение в квадрат результата предыдущей итерации, а значит в квадрат возводится и ошибка, т.е. она растет не линейно, а квадратично. Поэтому мы видим, что тесты перестали проходить, из-за несоответствия ожидаемого и полученного результатов в очень малых порядках числа.

Также можно заметить, что алгоритм с бинарным разложением степени по маске (**binary power**) в конечном итоге (в тесте 9) показал сильно отличающийся результат от алгоритма разбиения степени на четные и нечетные и домножением (**div power**). Дело в том, что **div power** реализован рекурсивно, домножение происходит в самом конце, в то время как **binary power** перемножает результаты, которые уже были не точные (с накопленной ошибкой) и очень высокой степени (`N=10000000000`) при очень близком к единице основании (`A=1.0000000001`) при квадратичном накапливании ошибки произошла проблема большой разницы порядков в целой части и в дробной части числа.

#### SENIOR. Поиска чисел Фибоначчи

Реализована система тестирования для алгоритмов:

* рекурсивный алгоритм (сложность **O(2^N)**)
* итеративный алгоритм (сложность **O(N)**)
* алгоритм Золотого Сечения (сложность **O(1)**)
* алгоритм через матричное возведение в степень через маску (сложность **O(log N)**)

Исходники системы тестирования находятся в файлах:

* `hw03/issue_fibo/checker_internals.cpp` - реализация core-функций системы тестирования
* `hw03/issue_fibo/checker_internals.h` - объявление core-функций
* `hw03/issue_fibo/checker.cpp` - собственно самая интересная часть

Сборка исходников системы тестирования происходит через `make`:

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_fibo$ make
g++ -lstdc++fs -std=c++17 -O2 -Wall -I. -o hw03_fibo_checker checker.cpp checker_internals.cpp algo_recursive.cpp algo_iterative.cpp algo_gold.cpp algo_matrix.cpp
```

Файлы для системы тестирования через файлы находятся в каталоге `hw03/issue_fibo/4.Fibo`

После запуска тестов, система сформирует сводную таблицу со временем исполнения по каждому тесту

```bash
dmitry@lachugin:~/otus/lachugin_algorithms_hw/hw03/issue_fibo$ ./hw03_fibo_checker 

Результаты теста рекурсивного алгоритма

Test 0 (       832 нс) : успех! ожидалось '0' получено '0'
Test 1 (       173 нс) : успех! ожидалось '1' получено '1'
Test 2 (       240 нс) : успех! ожидалось '1' получено '1'
Test 3 (       304 нс) : успех! ожидалось '2' получено '2'
Test 4 (       388 нс) : успех! ожидалось '3' получено '3'
Test 5 (       421 нс) : успех! ожидалось '5' получено '5'
Test 6 (      1889 нс) : успех! ожидалось '55' получено '55'
Test 7 ( 384772014 нс) : успех! ожидалось '102334155' получено '102334155'
Test 8 (        84 нс) : неудача! ожидалось '354224848179261915075' получено '0'
Test 9 (        37 нс) : неудача! получено '0'
Test 10 (        17 нс) : неудача! получено '0'
Test 11 (        21 нс) : неудача! получено '0'
Test 12 (        20 нс) : неудача! получено '0'
------------------
Количество тестов: 13
Успешно          : 8
Провалено        : 5

Результаты теста итеративного алгоритма

Test 0 (        50 нс) : успех! ожидалось '0' получено '0'
Test 1 (        32 нс) : успех! ожидалось '1' получено '1'
Test 2 (        52 нс) : успех! ожидалось '1' получено '1'
Test 3 (        51 нс) : успех! ожидалось '2' получено '2'
Test 4 (        52 нс) : успех! ожидалось '3' получено '3'
Test 5 (        53 нс) : успех! ожидалось '5' получено '5'
Test 6 (        80 нс) : успех! ожидалось '55' получено '55'
Test 7 (        86 нс) : успех! ожидалось '102334155' получено '102334155'
Test 8 (       101 нс) : успех! ожидалось '354224848179261915075' получено '354224848179261915075'
Test 9 (        60 нс) : неудача! получено '0'
Test 10 (        45 нс) : неудача! получено '0'
Test 11 (        19 нс) : неудача! получено '0'
Test 12 (        20 нс) : неудача! получено '0'
------------------
Количество тестов: 13
Успешно          : 9
Провалено        : 4

Результаты теста алгоритма Золотого Сечения

Test 0 (      9115 нс) : успех! ожидалось '0' получено '0'
Test 1 (      5295 нс) : успех! ожидалось '1' получено '1'
Test 2 (       178 нс) : успех! ожидалось '1' получено '1'
Test 3 (       159 нс) : успех! ожидалось '2' получено '2'
Test 4 (       187 нс) : успех! ожидалось '3' получено '3'
Test 5 (       109 нс) : успех! ожидалось '5' получено '5'
Test 6 (       120 нс) : успех! ожидалось '55' получено '55'
Test 7 (       116 нс) : успех! ожидалось '102334155' получено '102334155'
Test 8 (       186 нс) : неудача! ожидалось '354224848179261915075' получено '354224848179263111168'
Test 9 (        50 нс) : неудача! получено '0'
Test 10 (        31 нс) : неудача! получено '0'
Test 11 (        41 нс) : неудача! получено '0'
Test 12 (       137 нс) : неудача! получено '0'
------------------
Количество тестов: 13
Успешно          : 8
Провалено        : 5

Результаты теста алгоритма матричного перемножения

Test 0 (       240 нс) : успех! ожидалось '0' получено '0'
Test 1 (        29 нс) : успех! ожидалось '1' получено '1'
Test 2 (      1531 нс) : успех! ожидалось '1' получено '1'
Test 3 (      1388 нс) : успех! ожидалось '2' получено '2'
Test 4 (       785 нс) : успех! ожидалось '3' получено '3'
Test 5 (       724 нс) : успех! ожидалось '5' получено '5'
Test 6 (       879 нс) : успех! ожидалось '55' получено '55'
Test 7 (      1196 нс) : успех! ожидалось '102334155' получено '102334155'
Test 8 (      1345 нс) : успех! ожидалось '354224848179261915075' получено '354224848179261915075'
Test 9 (        53 нс) : неудача! получено '0'
Test 10 (        19 нс) : неудача! получено '0'
Test 11 (        21 нс) : неудача! получено '0'
Test 12 (        40 нс) : неудача! получено '0'
------------------
Количество тестов: 13
Успешно          : 9
Провалено        : 4

Сравнение затраченного времени на выполнение (нс)

Group name                Tets 0      Tets 1      Tets 2      Tets 3      Tets 4      Tets 5      Tets 6      Tets 7      Tets 8      Tets 9     Tets 10     Tets 11     Tets 12
gold                        9115        5295         178         159         187         109         120         116         186          50          31          41         137
iterative                     50          32          52          51          52          53          80          86         101          60          45          19          20
matrix                       240          29        1531        1388         785         724         879        1196        1345          53          19          21          40
recursive                    832         173         240         304         388         421        1889   384772014          84          37          17          21          20
```

**ПРИМЕЧАНИЕ 0:** Начиная с `Test 8` (расчет 1000 элемента ряда Фибоначчи) начинается переполнение типа данных `int128`, потому что итоговое целое число состоит из 209 разрядов. Поэтому я принудительно ограничил в алгоритмах N (если более 100, то не запускается).

**ПРИМЕЧАНИЕ 1:** Рекурсивный алгоритм при ограничении N>100 работает неприлично долго. Поэтому для него пришлось поставить N>50.

**ПРИМЕЧАНИЕ 2:** Раз уж изначально ясно, что 1000-й элемент никакой алгоритм не посчитает. Я немного подкорректировал исходный `Test 7` и `Test 8`. Теперь в `Test 7` мы ищем 40-й член ряда Фибоначчи (который равен 102334155), а в `Test 8` ищем 100-й член ряда Фибоначчи (который равен 354224848179261915075). Сделал я это исключительно чтобы сделать тесты немного более выразительными (для рекурсивного алгоритма)

**ПРИМЕЧАНИЕ 3:** Также можно заметить влияние кеша процессора, когда в ряде случаев вычисления полее дальних элементов ряда занимали ощутимо меньше времени, чем должны бы были математически. Поэтому дальнейший анализ не то чтобы очень качественный, скорее - общими мазками.

Из результатов можно видеть, что до `Test 7` (расчет 40 элемента ряда Фибоначчи, который равен 102334155) включительно - справились все 4 алгоритма. А вот с `Test 8` (расчет 100 элемента ряда Фибоначчи, который равен 354224848179261915075) удалось справиться только **итеративному** алгоритму и алгоритму **матричным способом** (**рекурсивный** мы сами вывели из игры, т.к. не дождались бы исполнения).

Алгоритм **Золотое Сечение** использует тип `double`, в результате чего, при вычислении формулы, при возведении в степени, при делениях - очень сильно накапливается ошибка, и на больших порядках N этот алгоритм начинает перемалывать мусор в `double`. Кроме того, вычисление `Test 0` и `Test 1` заняли у него аномально больше времени, из-за попыток вычисления очень малых значений и возведения в степень числел близких к 0. Однако затем алгоритм, как и ожидалось, выдавал практически постоянное время вычисления с увеличением порядка при поиске числа Фибоначчи.  
Т.е. по математике сложность **O(1)** и точность расчета - бесконечная! Но на практике, при реализации в коде, применять его можно только для очень малых порядков N, иначе получается мусор.

Алгоритм **рекурсивного** поиска имеет сложность **O(2^N)** и по результатам это наглядно видно (специально для него я и изменял пару Тестов, чтобы было нагляднее). Из-за рекурсии на каждом шаге создаются по 2 ветки вычислений. И чем больше шагов (чем больше порядок N), тем больше плодится веток. И в каждой ветке по итогу вычисляются те же значения fib(0), fib(1), ... огромное количество раз!

Алгоритм **итеративного** поиска имеет сложность **O(N)**, хотя по результатам тестов это тяжело видеть, потому что влияние оказывает кеш CPU, а также - показатели N в первых тестах изменяются очень медленно. Хотя ближе к `Test 6`, `Test 7` и `Test 8` (когда порядок N начинает изменяться быстрее) становится заметнее, как алгоритм замедляется.

Аналогично и для **матричного** алгоритма со сложностью **O(log N)**. Начинаем замечать изменения только ближе к `Test 6`, `Test 7` и `Test 8` (когда порядок N начинает изменяться быстрее). На результаты  `Test 0` и `Test 1` можно не обращать внимания, они не показательны, т.к. это заглушки. Сам порядок затраченного времени у **матричного** алгоритма сильно больше чем у **итеративного** подхода потому что "тело" вычислений намного тяжелее: рассчитываются матрицы, а это много операций умножений и сложений. В теории, для огромных N лучше подойдет именно **матричный** алгоритм, при этом сложность матричных вычислений окажется уже не такой большой, чем в **итеративном** подходе. Однако для таких огромных N, тип `int128` уже давно переполнится и останется позади и нужно будет пользоваться чем-то другим. Поэтому для практического применения оптимальным остается именно **итеративный** алгоритм.

#### SENIOR. Поиск количества простых чисел

Реализована система тестирования для алгоритмов:

* простой перебор делителей
* перебор делителей с оптимизацией поиска только до квадратного корня от N
* перебор делителей с оптимизацией поиска только по нечетным числам
* перебор делителей с оптимизацией поиска только до квадратного корня от N и исключая кратные 2 и 3
* перебор делителей с оптимизацией поиска делением только на простые числа
* алгоритм "Решето Эрастофена"

Исходники системы тестирования находятся в файлах:

* `hw03/issue_primes/checker_internals.cpp` - реализация core-функций системы тестирования
* `hw03/issue_primes/checker_internals.h` - объявление core-функций
* `hw03/issue_primes/checker.cpp` - собственно самая интересная часть

Сборка исходников системы тестирования происходит через `make`:

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_primes$ make
g++ -lstdc++fs -std=c++17 -O2 -Wall -I. -o hw03_primes_checker checker.cpp checker_internals.cpp algo_base.cpp algo_sqrt.cpp algo_odd.cpp algo_sqrt_div_2_3.cpp algo_div_primes.cpp algo_eratosthenes.cpp
```

Файлы для системы тестирования через файлы находятся в каталоге `hw03/issue_primes/5.Primes`

После запуска тестов, система сформирует сводную таблицу со временем исполнения по каждому тесту

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw03/issue_primes$ ./hw03_primes_checker 

Результаты теста алгоритма через перебор делителей

Test 0 (        1296 нс) : успех! ожидалось '4' получено '4'
Test 1 (         184 нс) : успех! ожидалось '0' получено '0'
Test 2 (         274 нс) : успех! ожидалось '1' получено '1'
Test 3 (         251 нс) : успех! ожидалось '2' получено '2'
Test 4 (         250 нс) : успех! ожидалось '2' получено '2'
Test 5 (         295 нс) : успех! ожидалось '3' получено '3'
Test 6 (       34247 нс) : успех! ожидалось '25' получено '25'
Test 7 (     2357991 нс) : успех! ожидалось '168' получено '168'
Test 8 (    60595690 нс) : успех! ожидалось '1229' получено '1229'
Test 9 (  2785485000 нс) : успех! ожидалось '9592' получено '9592'
Test 10 (          45 нс) : неудача! ожидалось '78498' получено '0'
Test 11 (          19 нс) : неудача! ожидалось '664579' получено '0'
Test 12 (          19 нс) : неудача! ожидалось '5761455' получено '0'
Test 13 (          26 нс) : неудача! ожидалось '50847534' получено '0'
Test 14 (          19 нс) : неудача! ожидалось '7027260' получено '0'
------------------
Количество тестов: 15
Успешно          : 10
Провалено        : 5

Результаты теста алгоритма через перебор делителей (оптимизация с квадратным корнем)

Test 0 (         225 нс) : успех! ожидалось '4' получено '4'
Test 1 (          38 нс) : успех! ожидалось '0' получено '0'
Test 2 (          53 нс) : успех! ожидалось '1' получено '1'
Test 3 (          41 нс) : успех! ожидалось '2' получено '2'
Test 4 (          43 нс) : успех! ожидалось '2' получено '2'
Test 5 (          51 нс) : успех! ожидалось '3' получено '3'
Test 6 (        1654 нс) : успех! ожидалось '25' получено '25'
Test 7 (       33264 нс) : успех! ожидалось '168' получено '168'
Test 8 (      748700 нс) : успех! ожидалось '1229' получено '1229'
Test 9 (    17817520 нс) : успех! ожидалось '9592' получено '9592'
Test 10 (          79 нс) : неудача! ожидалось '78498' получено '0'
Test 11 (          25 нс) : неудача! ожидалось '664579' получено '0'
Test 12 (          20 нс) : неудача! ожидалось '5761455' получено '0'
Test 13 (          29 нс) : неудача! ожидалось '50847534' получено '0'
Test 14 (          19 нс) : неудача! ожидалось '7027260' получено '0'
------------------
Количество тестов: 15
Успешно          : 10
Провалено        : 5

Результаты теста алгоритма через перебор делителей (оптимизация с поиском по нечетным)

Test 0 (         184 нс) : успех! ожидалось '4' получено '4'
Test 1 (          38 нс) : успех! ожидалось '0' получено '0'
Test 2 (          46 нс) : успех! ожидалось '1' получено '1'
Test 3 (          38 нс) : успех! ожидалось '2' получено '2'
Test 4 (          44 нс) : успех! ожидалось '2' получено '2'
Test 5 (          48 нс) : успех! ожидалось '3' получено '3'
Test 6 (        3572 нс) : успех! ожидалось '25' получено '25'
Test 7 (      248621 нс) : успех! ожидалось '168' получено '168'
Test 8 (    18853750 нс) : успех! ожидалось '1229' получено '1229'
Test 9 (  1483407684 нс) : успех! ожидалось '9592' получено '9592'
Test 10 (         100 нс) : неудача! ожидалось '78498' получено '0'
Test 11 (          25 нс) : неудача! ожидалось '664579' получено '0'
Test 12 (          18 нс) : неудача! ожидалось '5761455' получено '0'
Test 13 (          18 нс) : неудача! ожидалось '50847534' получено '0'
Test 14 (          20 нс) : неудача! ожидалось '7027260' получено '0'
------------------
Количество тестов: 15
Успешно          : 10
Провалено        : 5

Результаты теста алгоритма через перебор делителей (оптимизация с квадратным корнем исключая кратные 2 и 3)

Test 0 (         125 нс) : успех! ожидалось '4' получено '4'
Test 1 (         132 нс) : успех! ожидалось '0' получено '0'
Test 2 (          50 нс) : успех! ожидалось '1' получено '1'
Test 3 (          46 нс) : успех! ожидалось '2' получено '2'
Test 4 (          40 нс) : успех! ожидалось '2' получено '2'
Test 5 (          60 нс) : успех! ожидалось '3' получено '3'
Test 6 (         415 нс) : успех! ожидалось '25' получено '25'
Test 7 (        8473 нс) : успех! ожидалось '168' получено '168'
Test 8 (      208556 нс) : успех! ожидалось '1229' получено '1229'
Test 9 (     5289806 нс) : успех! ожидалось '9592' получено '9592'
Test 10 (   134319396 нс) : успех! ожидалось '78498' получено '78498'
Test 11 (  3476215164 нс) : успех! ожидалось '664579' получено '664579'
Test 12 (         150 нс) : неудача! ожидалось '5761455' получено '0'
Test 13 (          26 нс) : неудача! ожидалось '50847534' получено '0'
Test 14 (          25 нс) : неудача! ожидалось '7027260' получено '0'
------------------
Количество тестов: 15
Успешно          : 12
Провалено        : 3

Результаты теста алгоритма через перебор делителей (оптимизация с делением на простые числа и квадратным корнем)

Test 0 (         476 нс) : успех! ожидалось '4' получено '4'
Test 1 (          55 нс) : успех! ожидалось '0' получено '0'
Test 2 (          93 нс) : успех! ожидалось '1' получено '1'
Test 3 (         141 нс) : успех! ожидалось '2' получено '2'
Test 4 (          83 нс) : успех! ожидалось '2' получено '2'
Test 5 (         133 нс) : успех! ожидалось '3' получено '3'
Test 6 (        1767 нс) : успех! ожидалось '25' получено '25'
Test 7 (       23268 нс) : успех! ожидалось '168' получено '168'
Test 8 (      324497 нс) : успех! ожидалось '1229' получено '1229'
Test 9 (     5336538 нс) : успех! ожидалось '9592' получено '9592'
Test 10 (    99254012 нс) : успех! ожидалось '78498' получено '78498'
Test 11 (  1962124484 нс) : успех! ожидалось '664579' получено '664579'
Test 12 ( 42846513100 нс) : успех! ожидалось '5761455' получено '5761455'
Test 13 (         645 нс) : неудача! ожидалось '50847534' получено '0'
Test 14 (          27 нс) : неудача! ожидалось '7027260' получено '0'
------------------
Количество тестов: 15
Успешно          : 13
Провалено        : 2

Результаты теста алгоритма через решето Эрастофена

Test 0 (         201 нс) : успех! ожидалось '4' получено '4'
Test 1 (          72 нс) : успех! ожидалось '0' получено '0'
Test 2 (          74 нс) : успех! ожидалось '1' получено '1'
Test 3 (          61 нс) : успех! ожидалось '2' получено '2'
Test 4 (          92 нс) : успех! ожидалось '2' получено '2'
Test 5 (          82 нс) : успех! ожидалось '3' получено '3'
Test 6 (         347 нс) : успех! ожидалось '25' получено '25'
Test 7 (        2472 нс) : успех! ожидалось '168' получено '168'
Test 8 (       24489 нс) : успех! ожидалось '1229' получено '1229'
Test 9 (      257996 нс) : успех! ожидалось '9592' получено '9592'
Test 10 (     2776357 нс) : успех! ожидалось '78498' получено '78498'
Test 11 (    34049770 нс) : успех! ожидалось '664579' получено '664579'
Test 12 (   499052937 нс) : успех! ожидалось '5761455' получено '5761455'
Test 13 (  7487003054 нс) : успех! ожидалось '50847534' получено '50847534'
Test 14 (   658026995 нс) : успех! ожидалось '7027260' получено '7027260'
------------------
Количество тестов: 15
Успешно          : 15
Провалено        : 0

Сравнение затраченного времени на выполнение (нс)

Group name                   Tets 0         Tets 1         Tets 2         Tets 3         Tets 4         Tets 5         Tets 6         Tets 7         Tets 8         Tets 9        Tets 10        Tets 11        Tets 12        Tets 13        Tets 14
div primes                      201             72             74             61             92             82            347           2472          24489         257996        2776357       34049770      499052937     7487003054      658026995
sqrt div 2,3                    125            132             50             46             40             60            415           8473         208556        5289806      134319396     3476215164            150             26             25
odd                             184             38             46             38             44             48           3572         248621       18853750     1483407684            100             25             18             18             20
sqrt                            225             38             53             41             43             51           1654          33264         748700       17817520             79             25             20             29             19
base                           1296            184            274            251            250            295          34247        2357991       60595690     2785485000             45             19             19             26             19
```

**ПРИМЕЧАНИЕ:** большинство тестов я ограничил вводом числа 100000, чтобы вычисления не занимали слишком долго.  
алгоритм с делением на простые числа ограничил 100000000, у него асимптота получше.  
а алгоритм решета Эрастофена ограничил 1000000000, это максимальное значение из тестов

Из результатов видно как меняется зависимость времени выполнения от алгоритма. когда мы ограничивали перебор делителей до квадратного корня - эта оптимизация оказалась лучше, чем учет только нечетных. А когда мы включили все оптимизации, то время выполнения перебором делителей стало более вменяемым.

Хотя теоретические асимптоты этих алгоритмов (вариаций оптимизаций) стремятся по факту к **O(N^2)**, но в реальности выигрыш от оптимизаций может оказаться значительным!

Алгоритмы делением на простые числа и "Решето Эрастофена" позволяют улучшить производительность, снизить асимптотическую сложность алгоритма. Однако это происходит за счет того, что увеличивается сложность по памяти - приходится хранить все вычисленные результаты. А в алгоритмах перебора сложность по памяти была константной.
