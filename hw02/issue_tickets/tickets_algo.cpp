#include <vector>
#include <cctype>

#include "tickets_algo.h"

static uint64_t _calculate(int N)
{
    // АЛГОРИТМ
    // для каждой размерности (N) сумма (s) будет зависеть от суммы вариантов
    // в предыдущей размерности (N-1).
    // для каждой цифры (d) в размерности N сумма цифр размерности N-1 должна
    // дать ss=s-d, где s-d>=0.
    // так как возможных вариантов цифр у нас всего 10 (от 0 до 9),
    // то, чтобы определить общее количество вариантов, нужно просуммировать
    // количество частных вариантов сумм для d от 0 до 9.
    //
    // для примера:
    // двузначное (N=2) число XX. максимальная сумма цифр может быть 18 (99).
    // пробегаемся для каждой частной суммы от 0 до 18. в цикле:
    //   в частности рассмотрим сумму s=17.
    //   выбираем один разряд. цифры могут быть от 0 до 9. в цикле:
    //     цифра X0 (d=0).
    //       значит сумма цифр оставшихся разрядов ss=17-0=17 (17>=0).
    //       смотрим предыдущую размерность (N-1). количество вариантов,
    //       чтобы получить сумму 17 у однозначного (N=1) числа = 0
    //     цифра X1 (d=1).
    //       ... количество вариантов,
    //       чтобы получить сумму 16 у однозначного (N=1) числа = 0
    //     ...
    //     цифра X8 (d=8).
    //       значит сумма цифр оставшихся разрядов ss=17-8=9 (9>=0).
    //       смотрим предыдущую размерность (N-1). количество вариантов,
    //       чтобы получить сумму 9 у однозначного (N=1) числа = 1
    //     цифра X9 (d=9).
    //       значит сумма цифр оставшихся разрядов ss=17-9=8 (8>=0).
    //       смотрим предыдущую размерность (N-1). количество вариантов,
    //       чтобы получить сумму 8 у однозначного (N=1) числа = 1
    //   суммируем полученные варианты по всем цифрам: total=0+0+0+0+0+0+0+0+1+1=2.
    //   итого, для частной суммы s=17 для двузначного числа (XX) может быть 2 варианта.
    // закончив со всеми частными суммами двузначного числа (XX), останется просуммировать
    // полученные результаты

    // цифры могут быть от 0 до 9, поэтому максимальная возможная сумма если все 9-ки
    const int max_sum = 9*N;

    // определяем матрицу способов с помощь N цифр набрать сумму.
    // N+1 потому что добавим искусственный случай с 0 цифр.
    // max_sum+1 потому что от 0 и до 27, например.
    std::vector<std::vector<uint64_t>> matrix(N + 1, std::vector<uint64_t>(max_sum + 1, 0));

    // заполняем матрицу способов.
    // по умолчанию при создании она была заполнена нулями.
    // для базового случая, когда цифр нет вообще нам потребуется заглушка,
    // чтобы проще написать алгоритм. т.е. считаем, что возможность
    // с помощью 0 цифр набрать какую-то сумму - только одна, и эта сумма - 0
    matrix[0][0] = 1;
    for (int n = 1; n <= N; ++n) {
        for (int s = 0; s <= max_sum; ++s) {
            // определяем сколькими вариантами удастся получить сумму ss=s-d
            // для предыдущей цифры (смотрим на предыдущую размерность)
            // от 0 до 9 при положительной сумме цифр
            for (int d = 0; d <= 9; ++d) {
                if (s - d >= 0) matrix[n][s] += matrix[n - 1][s - d];
            }
        }
    }

    // s            0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27
    // ------------ --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
    // matrix[0][s] 1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
    // matrix[1][s] 1   1   1   1   1   1   1   1   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
    // matrix[2][s] 1   2   3   4   5   6   7   8   9   10  9   8   7   6   5   4   3   2   1   0   0   0   0   0   0   0   0   0
    // matrix[3][s] 1   3   6   10  15  21  28  36  45  55  63  69  73  75  75  73  69  63  55  45  36  28  21  15  10  6   3   1
#if 0
    std::cout << "s            ";
    for (int i = 0; i <= max_sum; ++i) {
        int p = i;
        if      (p >= 100) std::cout << p << " ";
        else if (p >= 10)  std::cout << p << "  ";
        else               std::cout << p << "   ";
    }
    std::cout << std::endl;
    std::cout << "matrix[0][s] ";
    for (int i = 0; i <= max_sum; ++i) {
        int p = matrix[0][i];
        if      (p >= 100) std::cout << p << " ";
        else if (p >= 10)  std::cout << p << "  ";
        else               std::cout << p << "   ";
    }
    std::cout << std::endl;
    for (int n = 1; n <= N; ++n) {
        std::cout << "matrix[" << n << "][s] ";
        for (int i = 0; i <= max_sum; ++i) {
            int p = matrix[n][i];
            if      (p >= 100) std::cout << p << " ";
            else if (p >= 10)  std::cout << p << "  ";
            else               std::cout << p << "   ";
        }
        std::cout << std::endl;
    }
#endif

    // т.к. у нас число с четным количеством цифр (2N) и мы посчитали сколько
    // способов получить суммы для одной его половинки (N), то столько же
    // способов будет и для другой его половинки. поэтому перемножаем
    uint64_t count = 0;
    for (int s = 0; s <= max_sum; ++s) {
        count += matrix[N][s] * matrix[N][s];
    }
    return count;
}

uint64_t count_lucky_tickets(const std::string& str)
{
    try {
        int N = std::stoi(str);
        if (N < 1 || N > 10) {
            std::cout << "значение N должно быть в диапазоне от 1 до 10: введено " << N << std::endl;
        } else {
            return _calculate(N);
        }
    } catch (const std::invalid_argument& e) {
        std::cerr << "неверный аргумент: " << e.what() << std::endl;
    } catch (const std::out_of_range& e) {
        std::cerr << "значение вне диапазона: " << e.what() << std::endl;
    }

    return 0;
}
