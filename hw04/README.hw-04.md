# ДЗ 04: Динамические массивы, неполный массив, очередь с приоритетом

## Цель

* Создание разных алгоритмов для реализации динамического массива
* Сравнение производительности разных алгоритмов для реализации динамического массива
* Создание приоритетной очереди или неполного массива

## Решение

### Реализация структур данных: динамические массивы и списки

Разработаны следующие варианты динамических массивов:

* `SingleArray` - массив изначально фиксированной длины (ёмкость массива задается при его создании).  
  Является реализацией интерфейса `hw04/IArray.h`.  
  Исходники расположены тут `hw04/SingleArray.h`.  
  Реаллокация памяти не предусмотрена.  
  По факту этот контейнер мало чем отличается от обычного массива, разве только дополнительно хранит информацию о количестве сохраненных в нем элементов, допустимой ёмкости, и управляет выделением и освобождением памяти.
* `VectorArray` - массив, который делает реаллокацию памяти с политикой **+1** для своего расширения.  
  Является реализацией интерфейса `hw04/IArray.h`.  
  Исходники расположены тут `hw04/VectorArray.h`.  
  Реаллокация памяти предусмотрена только в сторону увеличения, т.е. при удалении элементов не происходит уменьшения выделенной памяти.  
  Это по-настоящему динамический контейнер, в отличие от `SingleArray` умеет расти.
* `FactorArray` - массив, который делает реаллокацию памяти с политикой **x2** для своего расширения.  
  Является реализацией интерфейса `hw04/IArray.h`.  
  Исходники расположены тут `hw04/FactorArray.h`.  
  Реаллокация памяти предусмотрена только в сторону увеличения, т.е. при удалении элементов не происходит уменьшения выделенной памяти.  
  Это по-настоящему динамический контейнер, в отличие от `SingleArray` умеет расти. В отличие от `VectorArray` рост более агрессивный.
* `MatrixArray` - реализация свободного (рваного) массива.
  Является реализацией интерфейса `hw04/IArray.h`.  
  Исходники расположены тут `hw04/MatrixArray.h`.  
  Имеет фиксированный размер блоков (константой задано 10).  
  Позволяет динамически управлять количеством и положением этих блоков.  
  Реаллокация памяти предусмотрена только в сторону увеличения и частично в сторону уменьшения, т.е. при удалении элементов не происходит уменьшения выделенной памяти под количество блоков, хотя сам блок уничтожается и освобождается.  
  Блоки по 10 элементов могут быть не заполнены полностью, сохраняется информация о количестве элементов в блоке. Если блок опустел, то он удаляется целиком и указатели на последующие блоки смещаются. Если блок уже заполнен, то добавление нового элемента приводит к выделению следом нового блока и перемещению указателей на последующие блоки.  
  Таким образом, реализуется более сложная арифметика поиска позиции элемента, но меньшее количество перемещений в памяти.  
  Это по-настоящему динамический контейнер, который выдает средние показатели по использованию, но более щадаще работает с памятью.
* `ArrayList` - динамический массив на основе двусвязного списка.
  Является реализацией интерфейса `hw04/IArray.h`.  
  Исходники расположены тут `hw04/ArrayList.h`.  

Для сборки исходников запустить `make`:

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw04$ make
g++ -lstdc++fs -std=c++17 -Wall -I. -O0 -o hw04_dyn_arrays main_dyn_arrays.cpp
```

Для тестов в программе предусмотрено несколько сценариев:

* добавление элементов в конец
* добавление элементов в начало
* добавление элементов в середину
* произвольный доступ (по индексу для подсчета суммы)
* удаление элементов (каждый второй элемент начиная с середины)

Тесты реализуются на для каждого варианта динамического массива на следующих наборах:

* N=10
* N=100
* N=1000
* N=10000
* N=100000

После выполнения программа сформирует сводную таблицу. В таблице отображается кроме времени на исполнение также и количество операций реаллокаций памяти и итоговая ёмкость контейнера. Все контейнеры создаются с одинаковыми условиями ёмкости в 10 единиц (кроме `ArrayList`, по понятным причинам его ёмкость равно его размеру).

```bash
dmitry@lachugin:~/otus/lachugin_algorithms_hw/hw04$ ./hw04_dyn_arrays 
программа сравнения работы динамических массивов при разных размерах N
виды массивов: SingleArray, VectorArray, FactorArray, MatrixArray, ArrayList

                type        N  realloc    capacity  duration (ns)  description
          ----------  -------  -------    --------  -------------  -----------
    add to beginning       10        0          10            707  Массив фиксированного размера
    add to beginning       10        0          10            703  Динамический массив +1
    add to beginning       10        0          10            678  Динамический массив x2
    add to beginning       10        0          10            879  Свободный массив (по 10)
    add to beginning       10       10          10            537  На основе двусвязного списка

       random access       10        0          10            220  Массив фиксированного размера (sum=45) 
       random access       10        0          10            243  Динамический массив +1 (sum=45) 
       random access       10        0          10            220  Динамический массив x2 (sum=45) 
       random access       10        0          10            285  Свободный массив (по 10) (sum=45) 
       random access       10       10          10            400  На основе двусвязного списка (sum=45) 

  remove from middle       10        0          10            218  Массив фиксированного размера
  remove from middle       10        0          10            160  Динамический массив +1
  remove from middle       10        0          10            166  Динамический массив x2
  remove from middle       10        0          10            187  Свободный массив (по 10)
  remove from middle       10       10           8            240  На основе двусвязного списка

       add to middle       10        0          10            407  Массив фиксированного размера
       add to middle       10        0          10            559  Динамический массив +1
       add to middle       10        0          10            440  Динамический массив x2
       add to middle       10        0          10            535  Свободный массив (по 10)
       add to middle       10       10          10            625  На основе двусвязного списка

          add to end       10        0          10            280  Массив фиксированного размера
          add to end       10        0          10            241  Динамический массив +1
          add to end       10        0          10            268  Динамический массив x2
          add to end       10        0          10            317  Свободный массив (по 10)
          add to end       10       10          10            491  На основе двусвязного списка

                type        N  realloc    capacity  duration (ns)  description
          ----------  -------  -------    --------  -------------  -----------
    add to beginning      100        0          10          21929  Массив фиксированного размера. обработка остановлена, исключение: no space left
    add to beginning      100       90         100          28278  Динамический массив +1
    add to beginning      100        4         160          11928  Динамический массив x2
    add to beginning      100        9         100           4319  Свободный массив (по 10)
    add to beginning      100      100         100           3907  На основе двусвязного списка

       random access      100        0          10           1234  Массив фиксированного размера (sum=-45) 
       random access      100       90         100           1119  Динамический массив +1 (sum=4950) 
       random access      100        4         160           1165  Динамический массив x2 (sum=4950) 
       random access      100        9         100           2872  Свободный массив (по 10) (sum=4950) 
       random access      100      100         100           6487  На основе двусвязного списка (sum=4950) 

  remove from middle      100        0          10            241  Массив фиксированного размера
  remove from middle      100       90         100           1565  Динамический массив +1
  remove from middle      100        4         160           1577  Динамический массив x2
  remove from middle      100        9         100           1629  Свободный массив (по 10)
  remove from middle      100      100          83           1841  На основе двусвязного списка

       add to middle      100        0          10           4382  Массив фиксированного размера. обработка остановлена, исключение: no space left
       add to middle      100       90         100          32426  Динамический массив +1
       add to middle      100        4         160           8175  Динамический массив x2
       add to middle      100       53         540          17672  Свободный массив (по 10)
       add to middle      100      100         100           9413  На основе двусвязного списка

          add to end      100        0          10           3176  Массив фиксированного размера. обработка остановлена, исключение: no space left
          add to end      100       90         100          13518  Динамический массив +1
          add to end      100        4         160           2584  Динамический массив x2
          add to end      100        9         100           3045  Свободный массив (по 10)
          add to end      100      100         100           3093  На основе двусвязного списка

                type        N  realloc    capacity  duration (ns)  description
          ----------  -------  -------    --------  -------------  -----------
    add to beginning     1000        0          10           2915  Массив фиксированного размера. обработка остановлена, исключение: no space left
    add to beginning     1000      990        1000        1991363  Динамический массив +1
    add to beginning     1000        7        1280        1063361  Динамический массив x2
    add to beginning     1000       99        1000          59298  Свободный массив (по 10)
    add to beginning     1000     1000        1000          39390  На основе двусвязного списка

       random access     1000        0          10          11337  Массив фиксированного размера (sum=-945) 
       random access     1000      990        1000          10871  Динамический массив +1 (sum=499500) 
       random access     1000        7        1280          11043  Динамический массив x2 (sum=499500) 
       random access     1000       99        1000         151933  Свободный массив (по 10) (sum=499500) 
       random access     1000     1000        1000         543168  На основе двусвязного списка (sum=499500) 

  remove from middle     1000        0          10           1885  Массив фиксированного размера
  remove from middle     1000      990        1000          90595  Динамический массив +1
  remove from middle     1000        7        1280          90161  Динамический массив x2
  remove from middle     1000       99        1000          43218  Свободный массив (по 10)
  remove from middle     1000     1000         833          96658  На основе двусвязного списка

       add to middle     1000        0          10          14383  Массив фиксированного размера. обработка остановлена, исключение: no space left
       add to middle     1000      990        1000        1507428  Динамический массив +1
       add to middle     1000        7        1280         506139  Динамический массив x2
       add to middle     1000      548        5490        1245097  Свободный массив (по 10)
       add to middle     1000     1000        1000         671121  На основе двусвязного списка

          add to end     1000        0          10          14832  Массив фиксированного размера. обработка остановлена, исключение: no space left
          add to end     1000      990        1000        1034103  Динамический массив +1
          add to end     1000        7        1280          22812  Динамический массив x2
          add to end     1000       99        1000          44185  Свободный массив (по 10)
          add to end     1000     1000        1000          37721  На основе двусвязного списка

                type        N  realloc    capacity  duration (ns)  description
          ----------  -------  -------    --------  -------------  -----------
    add to beginning    10000        0          10           6381  Массив фиксированного размера. обработка остановлена, исключение: no space left
    add to beginning    10000     9990       10000      191916836  Динамический массив +1
    add to beginning    10000       10       10240       94492063  Динамический массив x2
    add to beginning    10000      999       10000        1425063  Свободный массив (по 10)
    add to beginning    10000    10000       10000         381272  На основе двусвязного списка

       random access    10000        0          10         114861  Массив фиксированного размера (sum=-9945) 
       random access    10000     9990       10000         108964  Динамический массив +1 (sum=49995000) 
       random access    10000       10       10240         109040  Динамический массив x2 (sum=49995000) 
       random access    10000      999       10000       16103044  Свободный массив (по 10) (sum=49995000) 
       random access    10000    10000       10000       62380405  На основе двусвязного списка (sum=49995000) 

  remove from middle    10000        0          10          17577  Массив фиксированного размера
  remove from middle    10000     9990       10000        8567676  Динамический массив +1
  remove from middle    10000       10       10240        8710499  Динамический массив x2
  remove from middle    10000      999       10000        4088733  Свободный массив (по 10)
  remove from middle    10000    10000        8333       10544127  На основе двусвязного списка

       add to middle    10000        0          10          15817  Массив фиксированного размера. обработка остановлена, исключение: no space left
       add to middle    10000     9990       10000      142914247  Динамический массив +1
       add to middle    10000       10       10240       47286273  Динамический массив x2
       add to middle    10000     5498       54990      124194927  Свободный массив (по 10)
       add to middle    10000    10000       10000      102739820  На основе двусвязного списка

          add to end    10000        0          10          18122  Массив фиксированного размера. обработка остановлена, исключение: no space left
          add to end    10000     9990       10000       95950754  Динамический массив +1
          add to end    10000       10       10240         208354  Динамический массив x2
          add to end    10000      999       10000        1449424  Свободный массив (по 10)
          add to end    10000    10000       10000         359987  На основе двусвязного списка

                type        N  realloc    capacity  duration (ns)  description
          ----------  -------  -------    --------  -------------  -----------
    add to beginning   100000        0          10          13075  Массив фиксированного размера. обработка остановлена, исключение: no space left
    add to beginning   100000    99990      100000    20497828370  Динамический массив +1
    add to beginning   100000       14      163840     9485130708  Динамический массив x2
    add to beginning   100000     9999      100000      102032758  Свободный массив (по 10)
    add to beginning   100000   100000      100000        3766944  На основе двусвязного списка

       random access   100000        0          10        1093163  Массив фиксированного размера (sum=-99945) 
       random access   100000    99990      100000        1089761  Динамический массив +1 (sum=4999950000) 
       random access   100000       14      163840        1112878  Динамический массив x2 (sum=4999950000) 
       random access   100000     9999      100000     1683645884  Свободный массив (по 10) (sum=4999950000) 
       random access   100000   100000      100000     6661640900  На основе двусвязного списка (sum=4999950000) 

  remove from middle   100000        0          10         168746  Массив фиксированного размера
  remove from middle   100000    99990      100000      851498166  Динамический массив +1
  remove from middle   100000       14      163840      853374638  Динамический массив x2
  remove from middle   100000     9999      100000      436446614  Свободный массив (по 10)
  remove from middle   100000   100000       83333     1057106474  На основе двусвязного списка

       add to middle   100000        0          10          18510  Массив фиксированного размера. обработка остановлена, исключение: no space left
       add to middle   100000    99990      100000    14033783668  Динамический массив +1
       add to middle   100000       14      163840     4658776630  Динамический массив x2
       add to middle   100000    54998      549990    16084182016  Свободный массив (по 10)
       add to middle   100000   100000      100000    11747346853  На основе двусвязного списка

          add to end   100000        0          10          13663  Массив фиксированного размера. обработка остановлена, исключение: no space left
          add to end   100000    99990      100000     9517819472  Динамический массив +1
          add to end   100000       14      163840        2203644  Динамический массив x2
          add to end   100000     9999      100000      100394156  Свободный массив (по 10)
          add to end   100000   100000      100000        3720701  На основе двусвязного списка
```

Из тестов можно видеть, что `SingleArray` отработал только на наборе `N=10`, на больших наборах цифры затраченного времени не имеют особого смысла, потому что он не может добавить в себя больше, это можно видеть из сообщения **`Массив фиксированного размера. обработка остановлена, исключение: no space left`**, по этой же причине и посчитать сумму он не смог, и тест удаления элементов тоже будет некорректен, т.к. в нем всего 10 элементов.

На наборе `N=10` можно видеть:

* **заполнение элементов массива с начала**.  
  лучше сего показывает себя `ArrayList`, т.к. перекладывать данные не нужно, нужно оперировать всего несколькими указателями, но от потребовал 10 выделений памяти, под каждый элемент.  
  `SingleArray`, `VectorArray` и `FactorArray` показали одинаковые результаты, т.е. никакого перевыделения памяти не требуется, массивы изначально имеют ёмкость 10 элементов.  
  `MatrixArray` оказался медленнее всех, хотя реаллокаций и не потребовалось, но там чуть сложнее арифметика поиска позиции элемента вначале, хотя в блоке приходилось всё также перекладывать элементы один за другим.
* **произвольный доступ по индексу**.  
  во всех вариантах массивов одинаков, кроме `ArrayList`. тут приходится аккумулировать индекс поэлементно итерируясь с головы или с хвоста списка.
* **удаление каждого второго с середины**.  
  хуже всего себя показывает `ArrayList`, потому что сначала ему нужно найти элемент по индексу, это долгая операция, хотя само удаление происходит быстро, элементы массива перекладывать не требуется.  
  `SingleArray`, `VectorArray` и `FactorArray` имеют абсолютно идентичную реализацию удаления, но показания времени `SingleArray` хуже всего, видимо тут вмешались оптимизации и кеширования в CPU.  
  у `MatrixArray` показатели чуть похуже, потому что арифметика определения индекса позиции элемента сложнее.
* **заполнение элементов с конца**.  
  `SingleArray`, `VectorArray` и `FactorArray` ведут себя лучше, потому что реаллоцировать память не надо, мы умещаемся в ёмкость массива, и перекладывать элементы не требуется.  
  у `MatrixArray` чуть сложнее арифметика, но суть та же.  
  для `ArrayList` добавление происходит быстро, но нужно найти индекс.
* **заполнение элементов с середины**.  
  в целом все показали одинаковые результаты. для всех массивов приходится перекладывать данные, а для списков - постоянно искать позицию для вставки.

Просматривая бОльщие размеры данных можно пронаблюдать следующее:

* **заполнение элементов массива с начала**.  
  `ArrayList` максимально быстро, меняем всего лишь указатели, но на каждый новый элемент требует выделение памяти.  
  `MatrixArray` среднее, иногда требует создание новых блоков, однако добавление элементов внутри блока приводит к перекладыванию элементов ТОЛЬКО внутри блока, а выделение памяти происходит кратно размеру блока.  
  `VectorArray` и `FactorArray` работают медленно, т.к. приходится перекладывать постоянно все элементы, хотя из-за большей агрессивности реаллоцирования памяти, `FactorArray` работает чуть быстрее, т.к. меньше перевыделений.
* **произвольный доступ по индексу**.  
  `VectorArray` и `FactorArray` фактически мгновенно, очень легко получить доступ к элементу.  
  `MatrixArray` средне и достаточно медленно, т.к. требует подсчета индекса элемента в рваном массиве, зависит от блоков.  
  `ArrayList` самый медленный, т.к. обратить по индексу на больших объемах данных становится сложнее из-за поэлементного перехода от головы/хвоста.
* **удаление каждого второго с середины**.  
  `VectorArray` и `FactorArray` очень медленные, из-за сдвига (перекладывания) всех последующих элементов.  
  `MatrixArray` сильно быстрее, т.е. перекладывание элементов требуется только в рамках одного блока и изредка удалине блоков.  
  `ArrayList` если говорить про удаление одного элемента, то быстро, главное посчитать позицию этого элемента, ведь ничего перекладывать не надо. но в случае удаления КАЖДОГО ВТОРОГО С СЕРЕДИНЫ очень много накладных расходов на поиск индексов этих **каждых вторых** элементов, для больших объемов это становится критичным.
* **заполнение элементов с конца**.  
  `FactorArray` быстро за счет агрессивной политики реаллоцирования памяти.  
  `ArrayList` быстро за счет оптимизации поиска с конца списка, иначе было бы очень медленно.  
  `MatrixArray` немного медленнее из-за сложной арифметики получения индекса элементов и необходимости создания новых блоков памяти.  
  `VectorArray` самый медленный, постоянно приходится реаллоцировать всё бОльший кусок памяти и перекладывать элементы в него.
* **заполнение элементов с середины**.  
  опять же, для больших объемов поведение похоже на поведение при `N=10`. в целом все показали почти одинаковые результаты. для всех массивов приходится перекладывать данные, а для списков - постоянно искать позицию для вставки.  
  но тут `FactorArray` выглядит чуть лучше, из-за агрессивной политики реаллокации памяти, он экономит на том, чтобы реже выделять и перекладывать элементы, хотя не бесплатно, он потребует большей ёмкости итогового массива.

### Реализация структур данных: приоритетная очередь

Структура данных "Приоритетная очередь" построена на массиве списков. Тут ключевой момент: количество приоритетов - фиксированное (очень частый сценарий использования). В динамическом массиве хранятся односвязные списки под каждый из приоритетов.

Исходники расположены тут `hw04/PriorityQueue.h`.

Для сборки исходников запустить `make`:

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw04$ make 
g++ -lstdc++fs -std=c++17 -Wall -I. -O0 -o hw04_priority_queue main_priority_queue.cpp
```

Для тестов в программе предусмотрено несколько сценариев:

* проверка базовых операций (пропихивание и извлечение с разными приоритетами)
* проверка правильной последовательности (сперва наивысшие приоритеты)
* проверка функции FIFO (очередь только с одним приоритетом)
* легкое нагрузочное тестирование

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw04$ ./hw04_priority_queue 
программа оценки работы структуры дынных PriorityQueue

===
=== проверка базовых операций
===
заполнение...
PriorityQueue (size=5):
  priority 3: 'high priority' 'other high priority' 
  priority 2: 'medium priority' 
  priority 1: 'low priority' 'other low priority' 
извлечение:
  'high priority'  'other high priority'  'medium priority'  'low priority'  'other low priority'

===
=== проверка правильной последовательности
===
заполнение...
PriorityQueue (size=7, highest priority=5):
  priority 5: 2 element(s)
  priority 4: 1 element(s)
  priority 3: 2 element(s)
  priority 2: 1 element(s)
  priority 1: 1 element(s)
ожидается: 50, 51, 40, 30, 31, 20, 10
извлечено: 50, 51, 40, 30, 31, 20, 10, 

===
=== проверка функции FIFO (одинаковый приоритет)
===
помещено в очередь (приоритет 1): 10
помещено в очередь (приоритет 1): 20
помещено в очередь (приоритет 1): 30
помещено в очередь (приоритет 1): 40
помещено в очередь (приоритет 1): 50
PriorityQueue (size=5, highest priority=1):
  priority 1: 5 element(s)
ожидается тот же порядок: 10, 20, 30, 40, 50
извлечено из очереди (приоритет 1): 10
извлечено из очереди (приоритет 1): 20
извлечено из очереди (приоритет 1): 30
извлечено из очереди (приоритет 1): 40
извлечено из очереди (приоритет 1): 50

===
=== проверка под нагрузкой
===
--- size: 100 ---
время заполнения (нс): 4025
PriorityQueue (size=100, highest priority=9):
  priority 9: 10 element(s)
  priority 8: 10 element(s)
  priority 7: 10 element(s)
  priority 6: 10 element(s)
  priority 5: 10 element(s)
  priority 4: 10 element(s)
  priority 3: 10 element(s)
  priority 2: 10 element(s)
  priority 1: 10 element(s)
  priority 0: 10 element(s)
время извлечения (нс): 1807

--- size: 1000 ---
время заполнения (нс): 31663
PriorityQueue (size=1000, highest priority=9):
  priority 9: 100 element(s)
  priority 8: 100 element(s)
  priority 7: 100 element(s)
  priority 6: 100 element(s)
  priority 5: 100 element(s)
  priority 4: 100 element(s)
  priority 3: 100 element(s)
  priority 2: 100 element(s)
  priority 1: 100 element(s)
  priority 0: 100 element(s)
время извлечения (нс): 14547

--- size: 10000 ---
время заполнения (нс): 313378
PriorityQueue (size=10000, highest priority=9):
  priority 9: 1000 element(s)
  priority 8: 1000 element(s)
  priority 7: 1000 element(s)
  priority 6: 1000 element(s)
  priority 5: 1000 element(s)
  priority 4: 1000 element(s)
  priority 3: 1000 element(s)
  priority 2: 1000 element(s)
  priority 1: 1000 element(s)
  priority 0: 1000 element(s)
время извлечения (нс): 145221

--- size: 100000 ---
время заполнения (нс): 3276488
PriorityQueue (size=100000, highest priority=9):
  priority 9: 10000 element(s)
  priority 8: 10000 element(s)
  priority 7: 10000 element(s)
  priority 6: 10000 element(s)
  priority 5: 10000 element(s)
  priority 4: 10000 element(s)
  priority 3: 10000 element(s)
  priority 2: 10000 element(s)
  priority 1: 10000 element(s)
  priority 0: 10000 element(s)
время извлечения (нс): 5921490

--- size: 155555 ---
время заполнения (нс): 8333459
PriorityQueue (size=155555, highest priority=9):
  priority 9: 15555 element(s)
  priority 8: 15555 element(s)
  priority 7: 15555 element(s)
  priority 6: 15555 element(s)
  priority 5: 15555 element(s)
  priority 4: 15556 element(s)
  priority 3: 15556 element(s)
  priority 2: 15556 element(s)
  priority 1: 15556 element(s)
  priority 0: 15556 element(s)
время извлечения (нс): 3935693
```

В дополнение, в классе было реализовано несколько методов для вывода статистики, чтоб было красивее наблюдать :)

Т.к. реализация - это динамический массив односвязных списков, то результаты по нагрузочным тестам ожидаемы. Легко переходить от приоритета к приоритету по индексу напрямую. Также легко заполнять очередь конкретного приоритета, т.к. это список то достаточно просто переопределить несколько указателей, внутри списка доступ по индексу не требуется. Двусвязный список не требуется, достаточно односвязного, т.к. реализуется очередь и добавление элементов всегда с головы. Но в тоже время т.к. это очередь, до доступ на извлечение элементов нужен с хвоста, поэтому для быстрого доступа достаточно хранить еще один указатель.

Такая реализация (массив списков) обеспечивает очень высокое быстродействие, а в реальных применениях как раз часто и применяется ограниченное количество приоритетов (например, в сетях (QoS), в планировщике задач в ОС, и т.д.), т.е. реализация списка списков (когда неограниченное количество приоритетов) чаще всего не требуется.

### Реализация структур данных: разреженный массив

Структура данных "Разряженный массив" построена на динамическом массиве строк. Каждая строка это односвязный список. Тут ключевой момент: структура помнит свои размеры MxN, а также дефолтное значение ячейки. В строках (односвязных списках) хранятся ячейки с недефолтными значениями (в ячейке записывается значение и номер колонки для которой эта ячейка). Благодаря такому списку строка может быть также "разяреженной". Также, для ускорения работы, строка знает количество ячеек в ней, чтобы каждый раз не пробегаться по списку.

Исходники расположены тут `hw04/SpaceArray.h`.

Для сборки исходников запустить `make`:

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw04$ make 
g++ -lstdc++fs -std=c++17 -Wall -I. -O0 -o hw04_space_array main_space_array.cpp
```

Для тестов в программе предусмотрено несколько сценариев:

* проверка базовых операций (инициализация дефолтными значениями, заполнение ячеек, сброс ячеек)
* проверка при использовании с изображением 100x100 и сравнение с обычным массивом

```bash
dmitry@lachugin:~/lachugin_algorithms_hw/hw04$ ./hw04_space_array 
программа оценки работы структуры дынных SpaceArray

===
=== проверка базовых операций
===
инициализированное состояние:
0 0 0 0 0 
0 0 0 0 0 
0 0 0 0 0 
0 0 0 0 0 
0 0 0 0 0 
установили значения:
1 0 0 0 0 
0 0 5 0 0 
0 0 0 0 3 
0 0 0 0 0 
0 0 0 0 7 
статистика до сброса ячейки (1,2):
SpaceArray: 5x5, default-value=0, non-default-count=4, density=16%
статистика после сброса ячейки (1,2):
SpaceArray: 5x5, default-value=0, non-default-count=3, density=12%

===
=== проверка на картинке оттенков серого
===
время заполнения (нс): 649691
размер для обычного массива: 10000
статистика для разряженного массива:
SpaceArray: 100x100, default-value=255, non-default-count=1257, density=12.57%
```

В дополнение, в классе было реализовано несколько методов для вывода статистики, чтоб было красивее наблюдать :)

Как видно из тестов, структура на основе динамического массива списков позволяет быстро обратиться к нужной строке (хотя искать ячейку в строке придется итеративно пробегаясь по элементам). А комбинация хранения дефолтного значения и списков с недефолтными ячейками - позволяет очень плотно хранить данные, в особенности, если эти матричные данные содержат > 80-90% одинаковых значений.
